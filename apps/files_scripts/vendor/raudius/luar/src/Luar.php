<?php
namespace Raudius\Luar;

use Raudius\Luar\Interpreter\Interpreter;
use Raudius\Luar\Interpreter\LuarObject\Invokable;
use Raudius\Luar\Interpreter\LuarObject\Literal;
use Raudius\Luar\Interpreter\LuarObject\LuarObject;
use Raudius\Luar\Interpreter\LuarObject\ObjectList;
use Raudius\Luar\Interpreter\LuarObject\Table;
use Raudius\Luar\Library\LibCore;
use Raudius\Luar\Library\LibMath;
use Raudius\Luar\Library\Library;
use Raudius\Luar\Library\LibString;
use Raudius\Luar\Library\LibTable;

class Luar {
	private Interpreter $interpreter;

	public function __construct() {
		$this->interpreter = new Interpreter();

		$this->addCoreLibrary(new LibCore());
		$this->addLibrary(new LibString());
		$this->addLibrary(new LibTable());
		$this->addLibrary(new LibMath());
	}

	/**
	 * Evaluates a Lua program.
	 *
	 * @param string $program
	 * @return mixed
	 */
	public function eval(string $program) {
		return static::unpackLuarObject($this->interpreter->eval($program));
	}

	/**
	 * Injects a variable or function into the global scope.
	 *
	 * @param string $name - Name of the variable
	 * @param mixed $value - variable or function to inject
	 * @return void
	 */
	public function assign(string $name, $value): void {
		$this->interpreter->getRoot()->assign($name, self::packLuarObject($value));
	}

	/**
	 * Calls a function in the global scope.
	 *
	 * @param string $name - name of the function
	 * @param array $args - arguments to be passed to the function
	 * @return mixed
	 * @throws LuarException - thrown if the name does not resolve to a global function
	 */
	public function call(string $name, array $args) {
		$invokable = $this->interpreter->getRoot()->get($name);
		if (!$invokable instanceof Invokable) {
			throw new LuarException('Could not call non-invokable object');
		}

		$args = array_map(static function ($arg): LuarObject {
			return self::packLuarObject($arg);
		}, $args);

		return static::unpackLuarObject($invokable->invoke(new ObjectList($args)));
	}

	/**
	 * Calls a closure generated by Luar.
	 *
	 * Might be useful, for example, if you define the function `myCustomFunction` which takes an argument a function, which you need to call inside the function handler.
	 * ```lua
	 * myCustomFunction(function (in)
	 *   local out
	 *   -- do something...
	 *   return out
	 * end)
	 * ```
	 *
	 * @param callable $closure
	 * @param array $args
	 * @return mixed
	 */
	public function callLuarClosure(callable $closure, array $args) {
		$args = array_map([$this, 'packLuarObject'], $args);

		$return = (new Invokable($closure))->invoke(new ObjectList($args));
		return static::unpackLuarObject($return);
	}

	/**
	 * Returns all the variables in the global scope as an array.
	 * The names of the variables will be the keys of the array.
	 * @return array
	 */
	public function getGlobals(): array {
		$globals = [];
		foreach ($this->interpreter->getRoot()->getAssigns() as $k => $o) {
			$globals[$k] = self::unpackLuarObject($o);
		}

		return $globals;
	}

	/**
	 * Adds a library to the interpreter.
	 * The functions will be added to a global table. The name of the table will match the name of the library.
	 * @param Library $library
	 * @return void
	 */
	public function addLibrary(Library $library): void {
		$functions = new Table(null, $library->getFunctions());
		$this->interpreter->getRoot()->assign($library->getName(), $functions);
		$this->interpreter->setMetaMethods(array_merge_recursive($this->interpreter->getMetaMethods(), $library->getMetaMethods()));
	}

	/**
	 * Adds a "core" library.
	 * Core library functions get added directly to the root scope and no meta-methods are expected.
	 *
	 * ```lua
	 * -- non-core library function example: `string.lower()`
	 * string.lower('HeLlO, wORLd!')
	 *
	 * -- core library function example: `type()`, `print()`
	 * local var = 'hello world'
	 * print(var)
	 * type(var)
	 * ```
	 * @param Library $library
	 */
	public function addCoreLibrary(Library $library): void {
		foreach ($library->getFunctions() as $name => $func) {
			$this->interpreter->getRoot()->assign($name, $func);
		}
	}

	/**
	 * Converts any PHP object to a `LuarObject`
	 *
	 * @param mixed $value
	 * @return LuarObject
	 */
	public static function packLuarObject($value): LuarObject {
		if ($value instanceof LuarObject) {
			return $value;
		}

		if (!is_string($value) && is_callable($value)) {
			return Invokable::fromPhpCallable($value);
		}

		if (is_array($value)) {
			return Table::fromArray($value);
		}
		return new Literal($value);
	}

	/**
	 * Converts a `LuarObject` to a PHP object
	 * @param LuarObject $object
	 * @return mixed
	 */
	public static function unpackLuarObject(LuarObject $object) {
		if ($object instanceof Table) {
			$table = [];
			foreach ($object->getValue() as $k => $value) {
				$table[$k] = self::unpackLuarObject($value);
			}

			return $table;
		}

		return $object->getValue();
	}
}
